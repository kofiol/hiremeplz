/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the GitHub repository of this plugin.
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/obsidian-periodic-notes-provider/main.js
var require_main = __commonJS({
  "node_modules/obsidian-periodic-notes-provider/main.js"(exports, module2) {
    var Mt = Object.create;
    var B = Object.defineProperty;
    var Ct = Object.getOwnPropertyDescriptor;
    var Rt = Object.getOwnPropertyNames;
    var Lt = Object.getPrototypeOf;
    var qt = Object.prototype.hasOwnProperty;
    var Yt = (n, t) => () => (t || n((t = { exports: {} }).exports, t), t.exports);
    var Ut = (n, t) => {
      for (var e in t) B(n, e, { get: t[e], enumerable: true });
    };
    var mt = (n, t, e, i) => {
      if (t && typeof t == "object" || typeof t == "function") for (let r of Rt(t)) !qt.call(n, r) && r !== e && B(n, r, { get: () => t[r], enumerable: !(i = Ct(t, r)) || i.enumerable });
      return n;
    };
    var C = (n, t, e) => (e = n != null ? Mt(Lt(n)) : {}, mt(t || !n || !n.__esModule ? B(e, "default", { value: n, enumerable: true }) : e, n));
    var jt = (n) => mt(B({}, "__esModule", { value: true }), n);
    var M = Yt((s) => {
      "use strict";
      Object.defineProperty(s, "__esModule", { value: true });
      var u = require("obsidian"), K = "YYYY-MM-DD", J = "gggg-[W]ww", gt = "YYYY-MM", pt = "YYYY-[Q]Q", ht = "YYYY";
      function R(n) {
        var e, i;
        let t = window.app.plugins.getPlugin("periodic-notes");
        return t && ((i = (e = t.settings) == null ? void 0 : e[n]) == null ? void 0 : i.enabled);
      }
      function L() {
        var n, t, e, i;
        try {
          let { internalPlugins: r, plugins: o } = window.app;
          if (R("daily")) {
            let { format: a, folder: d, template: p } = ((t = (n = o.getPlugin("periodic-notes")) == null ? void 0 : n.settings) == null ? void 0 : t.daily) || {};
            return { format: a || K, folder: (d == null ? void 0 : d.trim()) || "", template: (p == null ? void 0 : p.trim()) || "" };
          }
          let { folder: l, format: c, template: f } = ((i = (e = r.getPluginById("daily-notes")) == null ? void 0 : e.instance) == null ? void 0 : i.options) || {};
          return { format: c || K, folder: (l == null ? void 0 : l.trim()) || "", template: (f == null ? void 0 : f.trim()) || "" };
        } catch (r) {
          console.info("No custom daily note settings found!", r);
        }
      }
      function q() {
        var n, t, e, i, r, o, l;
        try {
          let c = window.app.plugins, f = (n = c.getPlugin("calendar")) == null ? void 0 : n.options, a = (e = (t = c.getPlugin("periodic-notes")) == null ? void 0 : t.settings) == null ? void 0 : e.weekly;
          if (R("weekly")) return { format: a.format || J, folder: ((i = a.folder) == null ? void 0 : i.trim()) || "", template: ((r = a.template) == null ? void 0 : r.trim()) || "" };
          let d = f || {};
          return { format: d.weeklyNoteFormat || J, folder: ((o = d.weeklyNoteFolder) == null ? void 0 : o.trim()) || "", template: ((l = d.weeklyNoteTemplate) == null ? void 0 : l.trim()) || "" };
        } catch (c) {
          console.info("No custom weekly note settings found!", c);
        }
      }
      function Y() {
        var t, e, i, r;
        let n = window.app.plugins;
        try {
          let o = R("monthly") && ((e = (t = n.getPlugin("periodic-notes")) == null ? void 0 : t.settings) == null ? void 0 : e.monthly) || {};
          return { format: o.format || gt, folder: ((i = o.folder) == null ? void 0 : i.trim()) || "", template: ((r = o.template) == null ? void 0 : r.trim()) || "" };
        } catch (o) {
          console.info("No custom monthly note settings found!", o);
        }
      }
      function U() {
        var t, e, i, r;
        let n = window.app.plugins;
        try {
          let o = R("quarterly") && ((e = (t = n.getPlugin("periodic-notes")) == null ? void 0 : t.settings) == null ? void 0 : e.quarterly) || {};
          return { format: o.format || pt, folder: ((i = o.folder) == null ? void 0 : i.trim()) || "", template: ((r = o.template) == null ? void 0 : r.trim()) || "" };
        } catch (o) {
          console.info("No custom quarterly note settings found!", o);
        }
      }
      function j() {
        var t, e, i, r;
        let n = window.app.plugins;
        try {
          let o = R("yearly") && ((e = (t = n.getPlugin("periodic-notes")) == null ? void 0 : t.settings) == null ? void 0 : e.yearly) || {};
          return { format: o.format || ht, folder: ((i = o.folder) == null ? void 0 : i.trim()) || "", template: ((r = o.template) == null ? void 0 : r.trim()) || "" };
        } catch (o) {
          console.info("No custom yearly note settings found!", o);
        }
      }
      function _t(...n) {
        let t = [];
        for (let i = 0, r = n.length; i < r; i++) t = t.concat(n[i].split("/"));
        let e = [];
        for (let i = 0, r = t.length; i < r; i++) {
          let o = t[i];
          !o || o === "." || e.push(o);
        }
        return t[0] === "" && e.unshift(""), e.join("/");
      }
      function Vt(n) {
        let t = n.substring(n.lastIndexOf("/") + 1);
        return t.lastIndexOf(".") != -1 && (t = t.substring(0, t.lastIndexOf("."))), t;
      }
      async function Ht(n) {
        let t = n.replace(/\\/g, "/").split("/");
        if (t.pop(), t.length) {
          let e = _t(...t);
          window.app.vault.getAbstractFileByPath(e) || await window.app.vault.createFolder(e);
        }
      }
      async function V(n, t) {
        t.endsWith(".md") || (t += ".md");
        let e = u.normalizePath(_t(n, t));
        return await Ht(e), e;
      }
      async function I(n) {
        let { metadataCache: t, vault: e } = window.app, i = u.normalizePath(n);
        if (i === "/") return Promise.resolve(["", null]);
        try {
          let r = t.getFirstLinkpathDest(i, ""), o = await e.cachedRead(r), l = window.app.foldManager.load(r);
          return [o, l];
        } catch (r) {
          return console.error(`Failed to read the daily note template '${i}'`, r), new u.Notice("Failed to read the daily note template"), ["", null];
        }
      }
      function P(n, t = "day") {
        let e = n.clone().startOf(t).format();
        return `${t}-${e}`;
      }
      function yt(n) {
        return n.replace(/\[[^\]]*\]/g, "");
      }
      function Wt(n, t) {
        if (t === "week") {
          let e = yt(n);
          return /w{1,2}/i.test(e) && (/M{1,4}/.test(e) || /D{1,4}/.test(e));
        }
        return false;
      }
      function O(n, t) {
        return wt(n.basename, t);
      }
      function zt(n, t) {
        return wt(Vt(n), t);
      }
      function wt(n, t) {
        let i = { day: L, week: q, month: Y, quarter: U, year: j }[t]().format.split("/").pop(), r = window.moment(n, i, true);
        if (!r.isValid()) return null;
        if (Wt(i, t) && t === "week") {
          let o = yt(i);
          if (/w{1,2}/i.test(o)) return window.moment(n, i.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""), false);
        }
        return r;
      }
      var Z = class extends Error {
      };
      async function bt(n) {
        let t = window.app, { vault: e } = t, i = window.moment, { template: r, format: o, folder: l } = L(), [c, f] = await I(r), a = n.format(o), d = await V(l, a);
        try {
          let p = await e.create(d, c.replace(/{{\s*date\s*}}/gi, a).replace(/{{\s*time\s*}}/gi, i().format("HH:mm")).replace(/{{\s*title\s*}}/gi, a).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (T, x, S, h, g, m) => {
            let G = i(), X = n.clone().set({ hour: G.get("hour"), minute: G.get("minute"), second: G.get("second") });
            return S && X.add(parseInt(h, 10), g), m ? X.format(m.substring(1).trim()) : X.format(o);
          }).replace(/{{\s*yesterday\s*}}/gi, n.clone().subtract(1, "day").format(o)).replace(/{{\s*tomorrow\s*}}/gi, n.clone().add(1, "d").format(o)));
          return t.foldManager.save(p, f), p;
        } catch (p) {
          console.error(`Failed to create file: '${d}'`, p), new u.Notice("Unable to create new file.");
        }
      }
      function Bt(n, t) {
        var e;
        return (e = t[P(n, "day")]) != null ? e : null;
      }
      function Qt() {
        let { vault: n } = window.app, { folder: t } = L(), e = n.getAbstractFileByPath(u.normalizePath(t));
        if (!e) throw new Z("Failed to find daily notes folder");
        let i = {};
        return u.Vault.recurseChildren(e, (r) => {
          if (r instanceof u.TFile) {
            let o = O(r, "day");
            if (o) {
              let l = P(o, "day");
              i[l] = r;
            }
          }
        }), i;
      }
      var tt = class extends Error {
      };
      function Gt() {
        let { moment: n } = window, t = n.localeData()._week.dow, e = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
        for (; t; ) e.push(e.shift()), t--;
        return e;
      }
      function Xt(n) {
        return Gt().indexOf(n.toLowerCase());
      }
      async function Ft(n) {
        let { vault: t } = window.app, { template: e, format: i, folder: r } = q(), [o, l] = await I(e), c = n.format(i), f = await V(r, c);
        try {
          let a = await t.create(f, o.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (d, p, T, x, S, h) => {
            let g = window.moment(), m = n.clone().set({ hour: g.get("hour"), minute: g.get("minute"), second: g.get("second") });
            return T && m.add(parseInt(x, 10), S), h ? m.format(h.substring(1).trim()) : m.format(i);
          }).replace(/{{\s*title\s*}}/gi, c).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (d, p, T) => {
            let x = Xt(p);
            return n.weekday(x).format(T.trim());
          }));
          return window.app.foldManager.save(a, l), a;
        } catch (a) {
          console.error(`Failed to create file: '${f}'`, a), new u.Notice("Unable to create new file.");
        }
      }
      function Kt(n, t) {
        var e;
        return (e = t[P(n, "week")]) != null ? e : null;
      }
      function Jt() {
        let n = {};
        if (!Pt()) return n;
        let { vault: t } = window.app, { folder: e } = q(), i = t.getAbstractFileByPath(u.normalizePath(e));
        if (!i) throw new tt("Failed to find weekly notes folder");
        return u.Vault.recurseChildren(i, (r) => {
          if (r instanceof u.TFile) {
            let o = O(r, "week");
            if (o) {
              let l = P(o, "week");
              n[l] = r;
            }
          }
        }), n;
      }
      var et = class extends Error {
      };
      async function Nt(n) {
        let { vault: t } = window.app, { template: e, format: i, folder: r } = Y(), [o, l] = await I(e), c = n.format(i), f = await V(r, c);
        try {
          let a = await t.create(f, o.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (d, p, T, x, S, h) => {
            let g = window.moment(), m = n.clone().set({ hour: g.get("hour"), minute: g.get("minute"), second: g.get("second") });
            return T && m.add(parseInt(x, 10), S), h ? m.format(h.substring(1).trim()) : m.format(i);
          }).replace(/{{\s*date\s*}}/gi, c).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, c));
          return window.app.foldManager.save(a, l), a;
        } catch (a) {
          console.error(`Failed to create file: '${f}'`, a), new u.Notice("Unable to create new file.");
        }
      }
      function Zt(n, t) {
        var e;
        return (e = t[P(n, "month")]) != null ? e : null;
      }
      function te() {
        let n = {};
        if (!vt()) return n;
        let { vault: t } = window.app, { folder: e } = Y(), i = t.getAbstractFileByPath(u.normalizePath(e));
        if (!i) throw new et("Failed to find monthly notes folder");
        return u.Vault.recurseChildren(i, (r) => {
          if (r instanceof u.TFile) {
            let o = O(r, "month");
            if (o) {
              let l = P(o, "month");
              n[l] = r;
            }
          }
        }), n;
      }
      var nt = class extends Error {
      };
      async function ee(n) {
        let { vault: t } = window.app, { template: e, format: i, folder: r } = U(), [o, l] = await I(e), c = n.format(i), f = await V(r, c);
        try {
          let a = await t.create(f, o.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (d, p, T, x, S, h) => {
            let g = window.moment(), m = n.clone().set({ hour: g.get("hour"), minute: g.get("minute"), second: g.get("second") });
            return T && m.add(parseInt(x, 10), S), h ? m.format(h.substring(1).trim()) : m.format(i);
          }).replace(/{{\s*date\s*}}/gi, c).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, c));
          return window.app.foldManager.save(a, l), a;
        } catch (a) {
          console.error(`Failed to create file: '${f}'`, a), new u.Notice("Unable to create new file.");
        }
      }
      function ne(n, t) {
        var e;
        return (e = t[P(n, "quarter")]) != null ? e : null;
      }
      function ie() {
        let n = {};
        if (!Tt()) return n;
        let { vault: t } = window.app, { folder: e } = U(), i = t.getAbstractFileByPath(u.normalizePath(e));
        if (!i) throw new nt("Failed to find quarterly notes folder");
        return u.Vault.recurseChildren(i, (r) => {
          if (r instanceof u.TFile) {
            let o = O(r, "quarter");
            if (o) {
              let l = P(o, "quarter");
              n[l] = r;
            }
          }
        }), n;
      }
      var it = class extends Error {
      };
      async function re(n) {
        let { vault: t } = window.app, { template: e, format: i, folder: r } = j(), [o, l] = await I(e), c = n.format(i), f = await V(r, c);
        try {
          let a = await t.create(f, o.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (d, p, T, x, S, h) => {
            let g = window.moment(), m = n.clone().set({ hour: g.get("hour"), minute: g.get("minute"), second: g.get("second") });
            return T && m.add(parseInt(x, 10), S), h ? m.format(h.substring(1).trim()) : m.format(i);
          }).replace(/{{\s*date\s*}}/gi, c).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, c));
          return window.app.foldManager.save(a, l), a;
        } catch (a) {
          console.error(`Failed to create file: '${f}'`, a), new u.Notice("Unable to create new file.");
        }
      }
      function oe(n, t) {
        var e;
        return (e = t[P(n, "year")]) != null ? e : null;
      }
      function se() {
        let n = {};
        if (!xt()) return n;
        let { vault: t } = window.app, { folder: e } = j(), i = t.getAbstractFileByPath(u.normalizePath(e));
        if (!i) throw new it("Failed to find yearly notes folder");
        return u.Vault.recurseChildren(i, (r) => {
          if (r instanceof u.TFile) {
            let o = O(r, "year");
            if (o) {
              let l = P(o, "year");
              n[l] = r;
            }
          }
        }), n;
      }
      function ae() {
        var i, r;
        let { app: n } = window, t = n.internalPlugins.plugins["daily-notes"];
        if (t && t.enabled) return true;
        let e = n.plugins.getPlugin("periodic-notes");
        return e && ((r = (i = e.settings) == null ? void 0 : i.daily) == null ? void 0 : r.enabled);
      }
      function Pt() {
        var e, i;
        let { app: n } = window;
        if (n.plugins.getPlugin("calendar")) return true;
        let t = n.plugins.getPlugin("periodic-notes");
        return t && ((i = (e = t.settings) == null ? void 0 : e.weekly) == null ? void 0 : i.enabled);
      }
      function vt() {
        var e, i;
        let { app: n } = window, t = n.plugins.getPlugin("periodic-notes");
        return t && ((i = (e = t.settings) == null ? void 0 : e.monthly) == null ? void 0 : i.enabled);
      }
      function Tt() {
        var e, i;
        let { app: n } = window, t = n.plugins.getPlugin("periodic-notes");
        return t && ((i = (e = t.settings) == null ? void 0 : e.quarterly) == null ? void 0 : i.enabled);
      }
      function xt() {
        var e, i;
        let { app: n } = window, t = n.plugins.getPlugin("periodic-notes");
        return t && ((i = (e = t.settings) == null ? void 0 : e.yearly) == null ? void 0 : i.enabled);
      }
      function le(n) {
        let t = { day: L, week: q, month: Y, quarter: U, year: j }[n];
        return t();
      }
      function ce(n, t) {
        return { day: bt, month: Nt, week: Ft }[n](t);
      }
      s.DEFAULT_DAILY_NOTE_FORMAT = K;
      s.DEFAULT_MONTHLY_NOTE_FORMAT = gt;
      s.DEFAULT_QUARTERLY_NOTE_FORMAT = pt;
      s.DEFAULT_WEEKLY_NOTE_FORMAT = J;
      s.DEFAULT_YEARLY_NOTE_FORMAT = ht;
      s.appHasDailyNotesPluginLoaded = ae;
      s.appHasMonthlyNotesPluginLoaded = vt;
      s.appHasQuarterlyNotesPluginLoaded = Tt;
      s.appHasWeeklyNotesPluginLoaded = Pt;
      s.appHasYearlyNotesPluginLoaded = xt;
      s.createDailyNote = bt;
      s.createMonthlyNote = Nt;
      s.createPeriodicNote = ce;
      s.createQuarterlyNote = ee;
      s.createWeeklyNote = Ft;
      s.createYearlyNote = re;
      s.getAllDailyNotes = Qt;
      s.getAllMonthlyNotes = te;
      s.getAllQuarterlyNotes = ie;
      s.getAllWeeklyNotes = Jt;
      s.getAllYearlyNotes = se;
      s.getDailyNote = Bt;
      s.getDailyNoteSettings = L;
      s.getDateFromFile = O;
      s.getDateFromPath = zt;
      s.getDateUID = P;
      s.getMonthlyNote = Zt;
      s.getMonthlyNoteSettings = Y;
      s.getPeriodicNoteSettings = le;
      s.getQuarterlyNote = ne;
      s.getQuarterlyNoteSettings = U;
      s.getTemplateInfo = I;
      s.getWeeklyNote = Kt;
      s.getWeeklyNoteSettings = q;
      s.getYearlyNote = oe;
      s.getYearlyNoteSettings = j;
    });
    var be = {};
    Ut(be, { DEFAULT_SETTINGS: () => W, DailyNote: () => rt, MonthlyNote: () => ot, PERIODIC_NOTES_EVENT_SETTING_UPDATED: () => we, PLUGIN_NAME: () => Q, PeriodicNotesPluginAdapter: () => dt, QuarterlyNote: () => st, V0Provider: () => H, V1Provider: () => z, WeeklyNote: () => at, YearlyNote: () => lt, checkCreateTime: () => v });
    module2.exports = jt(be);
    var St = require("obsidian");
    var y = C(M());
    var ue = 15e3;
    var _ = class {
    };
    function v(n) {
      return n.stat.ctime > (/* @__PURE__ */ new Date()).getTime() - ue;
    }
    var fe = 30;
    var D = "day";
    var rt = class extends _ {
      getDate() {
        return (0, St.moment)().startOf(D);
      }
      async create() {
        let t = this.getDate().clone().startOf(D);
        return (0, y.createDailyNote)(t);
      }
      getAllPaths() {
        let t = (0, y.getAllDailyNotes)();
        return Object.entries(t).map(([e, i]) => i.path);
      }
      getCurrent() {
        return (0, y.getDailyNote)(this.getDate(), (0, y.getAllDailyNotes)());
      }
      getNextDate() {
        return this.getDate().clone().add(1, D);
      }
      getPrevious() {
        let t = this.getDate().clone().subtract(1, D), e = t.clone().subtract(fe, D), i = (0, y.getAllDailyNotes)(), r;
        do
          r = (0, y.getDailyNote)(t, i), t.subtract(1, D);
        while (!r && t.isAfter(e));
        return r;
      }
      isPresent() {
        let t = this.getDate().clone().startOf(D), e = (0, y.getAllDailyNotes)();
        return !!(0, y.getDailyNote)(t, e);
      }
      isValid(t) {
        let e = (0, y.getDailyNote)(this.getDate(), (0, y.getAllDailyNotes)());
        return e ? e.name === t.name && v(e) : false;
      }
    };
    var Dt = require("obsidian");
    var w = C(M());
    var de = 12;
    var k = "month";
    var ot = class extends _ {
      getDate() {
        return (0, Dt.moment)().startOf(k);
      }
      async create() {
        let t = this.getDate().clone().startOf(k);
        return (0, w.createMonthlyNote)(t);
      }
      getAllPaths() {
        let t = (0, w.getAllMonthlyNotes)();
        return Object.entries(t).map(([e, i]) => i.path);
      }
      getCurrent() {
        return (0, w.getMonthlyNote)(this.getDate(), (0, w.getAllMonthlyNotes)());
      }
      getNextDate() {
        return this.getDate().clone().add(1, k);
      }
      getPrevious() {
        let t = this.getDate().clone().subtract(1, k), e = t.clone().subtract(de, k), i = (0, w.getAllMonthlyNotes)(), r;
        do
          r = (0, w.getMonthlyNote)(t, i), t.subtract(1, k);
        while (!r && t.isAfter(e));
        return r;
      }
      isPresent() {
        let t = this.getDate().clone().startOf(k), e = (0, w.getAllMonthlyNotes)();
        return !!(0, w.getMonthlyNote)(t, e);
      }
      isValid(t) {
        let e = (0, w.getMonthlyNote)(this.getDate(), (0, w.getAllMonthlyNotes)());
        return e ? e.name === t.name && v(e) : false;
      }
    };
    var kt = require("obsidian");
    var b = C(M());
    var me = 4;
    var $ = "quarter";
    var st = class extends _ {
      getDate() {
        return (0, kt.moment)().startOf($);
      }
      async create() {
        let t = this.getDate().clone().startOf($);
        return (0, b.createQuarterlyNote)(t);
      }
      getAllPaths() {
        let t = (0, b.getAllQuarterlyNotes)();
        return Object.entries(t).map(([e, i]) => i.path);
      }
      getCurrent() {
        return (0, b.getQuarterlyNote)(this.getDate(), (0, b.getAllQuarterlyNotes)());
      }
      getNextDate() {
        return this.getDate().clone().add(1, $);
      }
      getPrevious() {
        let t = this.getDate().clone().subtract(1, $), e = t.clone().subtract(me, $), i = (0, b.getAllQuarterlyNotes)(), r;
        do
          r = (0, b.getQuarterlyNote)(t, i), t.subtract(1, $);
        while (!r && t.isAfter(e));
        return r;
      }
      isPresent() {
        let t = this.getDate().clone().startOf($), e = (0, b.getAllQuarterlyNotes)();
        return !!(0, b.getQuarterlyNote)(t, e);
      }
      isValid(t) {
        let e = (0, b.getQuarterlyNote)(this.getDate(), (0, b.getAllQuarterlyNotes)());
        return e ? e.name === t.name && v(e) : false;
      }
    };
    var $t = require("obsidian");
    var F = C(M());
    var ge = 8;
    var A = "week";
    var at = class extends _ {
      getDate() {
        return (0, $t.moment)().startOf(A);
      }
      async create() {
        let t = this.getDate().clone().startOf(A);
        return (0, F.createWeeklyNote)(t);
      }
      getAllPaths() {
        let t = (0, F.getAllWeeklyNotes)();
        return Object.entries(t).map(([e, i]) => i.path);
      }
      getCurrent() {
        return (0, F.getWeeklyNote)(this.getDate(), (0, F.getAllWeeklyNotes)());
      }
      getNextDate() {
        return this.getDate().clone().add(1, A);
      }
      getPrevious() {
        let t = this.getDate().clone().subtract(1, A), e = t.clone().subtract(ge, A), i = (0, F.getAllWeeklyNotes)(), r;
        do
          r = (0, F.getWeeklyNote)(t, i), t.subtract(1, A);
        while (!r && t.isAfter(e));
        return r;
      }
      isPresent() {
        let t = this.getDate().clone().startOf(A), e = (0, F.getAllWeeklyNotes)();
        return !!(0, F.getWeeklyNote)(t, e);
      }
      isValid(t) {
        let e = (0, F.getWeeklyNote)(this.getDate(), (0, F.getAllWeeklyNotes)());
        return e ? e.name === t.name && v(e) : false;
      }
    };
    var At = require("obsidian");
    var N = C(M());
    var pe = 5;
    var E = "year";
    var lt = class extends _ {
      getDate() {
        return (0, At.moment)().startOf(E);
      }
      async create() {
        let t = this.getDate().clone().startOf(E);
        return (0, N.createYearlyNote)(t);
      }
      getAllPaths() {
        let t = (0, N.getAllYearlyNotes)();
        return Object.entries(t).map(([e, i]) => i.path);
      }
      getCurrent() {
        return (0, N.getYearlyNote)(this.getDate(), (0, N.getAllYearlyNotes)());
      }
      getNextDate() {
        return this.getDate().clone().add(1, E);
      }
      getPrevious() {
        let t = this.getDate().clone().subtract(1, E), e = t.clone().subtract(pe, E), i = (0, N.getAllYearlyNotes)(), r;
        do
          r = (0, N.getYearlyNote)(t, i), t.subtract(1, E);
        while (!r && t.isAfter(e));
        return r;
      }
      isPresent() {
        let t = this.getDate().clone().startOf(E), e = (0, N.getAllYearlyNotes)();
        return !!(0, N.getYearlyNote)(t, e);
      }
      isValid(t) {
        let e = (0, N.getYearlyNote)(this.getDate(), (0, N.getAllYearlyNotes)());
        return e ? e.name === t.name && v(e) : false;
      }
    };
    var H = class {
      convertSettings(t) {
        let e = t, i = Object.assign({}, W);
        return i.daily.available = e.daily.enabled, i.weekly.available = e.weekly.enabled, i.monthly.available = e.monthly.enabled, i.quarterly.available = e.quarterly.enabled, i.yearly.available = e.yearly.enabled, i;
      }
    };
    function ct() {
    }
    function Et(n) {
      return n();
    }
    function ut(n) {
      n.forEach(Et);
    }
    function It(n) {
      return typeof n == "function";
    }
    function he(n) {
      return Object.keys(n).length === 0;
    }
    function Ot(n, ...t) {
      if (n == null) return ct;
      let e = n.subscribe(...t);
      return e.unsubscribe ? () => e.unsubscribe() : e;
    }
    function ft(n) {
      let t;
      return Ot(n, (e) => t = e)(), t;
    }
    var Je = Promise.resolve();
    var Ze = typeof window != "undefined" ? window : typeof globalThis != "undefined" ? globalThis : global;
    function _e(n, t) {
      let e = n.$$;
      e.fragment !== null && (ut(e.on_destroy), e.fragment && e.fragment.d(t), e.on_destroy = e.fragment = null, e.ctx = []);
    }
    var ye;
    typeof HTMLElement == "function" && (ye = class extends HTMLElement {
      constructor() {
        super(), this.attachShadow({ mode: "open" });
      }
      connectedCallback() {
        let { on_mount: n } = this.$$;
        this.$$.on_disconnect = n.map(Et).filter(It);
        for (let t in this.$$.slotted) this.appendChild(this.$$.slotted[t]);
      }
      attributeChangedCallback(n, t, e) {
        this[n] = e;
      }
      disconnectedCallback() {
        ut(this.$$.on_disconnect);
      }
      $destroy() {
        _e(this, 1), this.$destroy = ct;
      }
      $on(n, t) {
        let e = this.$$.callbacks[n] || (this.$$.callbacks[n] = []);
        return e.push(t), () => {
          let i = e.indexOf(t);
          i !== -1 && e.splice(i, 1);
        };
      }
      $set(n) {
        this.$$set && !he(n) && (this.$$.skip_bound = true, this.$$set(n), this.$$.skip_bound = false);
      }
    });
    var z = class {
      convertSettings(t) {
        var l, c, f, a, d;
        let i = ft(t), r = i.calendarSets.filter((p) => p.id === i.activeCalendarSet), o = Object.assign({}, W);
        return o.daily.available = false, o.weekly.available = false, o.monthly.available = false, o.quarterly.available = false, o.yearly.available = false, r.length && (o.daily.available = ((l = r[0].day) == null ? void 0 : l.enabled) || false, o.weekly.available = ((c = r[0].week) == null ? void 0 : c.enabled) || false, o.monthly.available = ((f = r[0].month) == null ? void 0 : f.enabled) || false, o.quarterly.available = ((a = r[0].quarter) == null ? void 0 : a.enabled) || false, o.yearly.available = ((d = r[0].year) == null ? void 0 : d.enabled) || false), o;
      }
    };
    var dt = class {
      constructor(t) {
        this.app = t;
      }
      getProvider() {
        return this.getPlugin().settings.daily !== void 0 ? new H() : new z();
      }
      getPlugin() {
        return this.app.plugins.getPlugin(Q);
      }
      isEnabled() {
        return this.app.plugins.enabledPlugins.has(Q);
      }
      convertSettings() {
        return this.getProvider().convertSettings(this.getPlugin().settings);
      }
    };
    var we = "periodic-notes:settings-updated";
    var Q = "periodic-notes";
    var W = { daily: { available: false }, weekly: { available: false }, monthly: { available: false }, quarterly: { available: false }, yearly: { available: false } };
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  default: () => AutoTasks
});
module.exports = __toCommonJS(index_exports);
var import_obsidian9 = require("obsidian");
var import_obsidian_periodic_notes_provider2 = __toESM(require_main());

// src/events.ts
var SETTINGS_UPDATED = "auto-tasks:settings-updated";

// src/kanban/board.ts
var UPCOMING = "## Upcoming";
var DUE = "## Due";
var PROGRESS = "## In progress";
var DONE = "## Done";
var COMPLETE = "**Complete**";
var KANBAN_PROPERTY_NAME = "kanban-plugin";
var KANBAN_PROPERTY_VALUE = "board";
var ARCHIVE = "## Archive";
var ARCHIVE_DIVIDER = "\n***\n";
var HEADER = `
---

${KANBAN_PROPERTY_NAME}: ${KANBAN_PROPERTY_VALUE}

---
`.trim();
var FOOTER = `
%% kanban:settings
\`\`\`
{"kanban-plugin":"board","list-collapse":[false,false,false,false]}
\`\`\`
%%
`.trim();
var KanbanBoard = class {
  constructor(taskFactory, fileName, contents, archiveContents) {
    this.taskFactory = taskFactory;
    this.fileName = fileName;
    if (!contents) {
      contents = `${UPCOMING}



${DUE}



${PROGRESS}



${DONE}



`;
    }
    if (!archiveContents) {
      archiveContents = `${ARCHIVE}



`;
    }
    this.contents = contents;
    this.archiveContents = archiveContents;
  }
  getArchive() {
    if (!this.tasksArchive) {
      this.tasksArchive = this.taskFactory.newCollection(this.archiveContents, false);
    }
    return this.tasksArchive;
  }
  getFileName() {
    return this.fileName;
  }
  getTaskCollection() {
    if (!this.tasks) {
      this.tasks = this.taskFactory.newCollection(this.contents, true);
    }
    return this.tasks;
  }
  toString() {
    let tasks = this.getTaskCollection().toString("\n\n\n\n");
    tasks = tasks.replace(`${DONE}
`, `${DONE}

${COMPLETE}`);
    if (this.getArchive().getAllTasks().length) {
      return `${HEADER}

${tasks}
${ARCHIVE_DIVIDER}
${this.getArchive().toString()}

${FOOTER}`;
    }
    return `${HEADER}

${tasks}

${FOOTER}`;
  }
};

// src/kanban/board-manager.ts
var KanbanBoardManager = class {
  constructor(vault, metadataCache, taskFactory) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.taskFactory = taskFactory;
  }
  getAllBoards() {
    const boards = [];
    for (const file of this.vault.getFiles()) {
      if (this.isBoard(file)) {
        boards.push(file);
      }
    }
    return boards;
  }
  isBoard(file) {
    const fileCache = this.metadataCache.getFileCache(file);
    if (fileCache === null) {
      return false;
    }
    if (fileCache.frontmatter === void 0) {
      return false;
    }
    if (typeof fileCache.frontmatter[KANBAN_PROPERTY_NAME] === "undefined") {
      return false;
    }
    return fileCache.frontmatter[KANBAN_PROPERTY_NAME] === KANBAN_PROPERTY_VALUE;
  }
  async get(fileName) {
    const file = this.vault.getFileByPath(fileName);
    if (file === null) {
      throw new KanbanBoardOpenError();
    }
    const boardContents = (await this.vault.read(file)).split(ARCHIVE_DIVIDER);
    return new KanbanBoard(this.taskFactory, fileName, boardContents[0], boardContents.length > 1 ? boardContents[1] : "");
  }
};
var KanbanBoardOpenError = class extends Error {
};

// src/kanban/synchroniser.ts
var import_obsidian = require("obsidian");
var KanbanSynchroniser = class {
  constructor(plugin, vault, taskFactory) {
    this.plugin = plugin;
    this.vault = vault;
    this.taskFactory = taskFactory;
  }
  async process(board, files) {
    if (!files || !files.length) {
      files = this.vault.getFiles();
    }
    files = files.filter((file) => {
      let valid = true;
      this.plugin.getSettings().kanbanIgnoreFolders.forEach((folder) => {
        if (file.path.startsWith(folder + "/")) {
          valid = false;
        }
      });
      return valid;
    });
    for (const file of files) {
      if (file.name !== board.getFileName()) {
        await this.processSingle(board, file);
      }
    }
    await this.archiveOldTasks(board);
    const boardFile = this.vault.getFileByPath(board.getFileName());
    if (boardFile instanceof import_obsidian.TFile) {
      await this.vault.modify(boardFile, board.toString());
    }
  }
  async processSingle(board, file) {
    const kanbanTasks = board.getTaskCollection();
    const fileTasks = this.taskFactory.newCollection(await this.vault.read(file), true).getAllTasks();
    for (const task of fileTasks) {
      if (this.plugin.getSettings().kanbanIgnoreMatches.filter((ignore) => task.getName().match(ignore)).length > 0) {
        continue;
      }
      ;
      const existingTask = kanbanTasks.getTask(task);
      if (!existingTask) {
        kanbanTasks.add(task);
      } else {
        if (!task.isComplete() && kanbanTasks.getList(task) === DONE) {
          kanbanTasks.move(task, task.isDue() ? DUE : UPCOMING);
        } else if (task.isDue() && !task.isComplete()) {
          if (kanbanTasks.getList(task) !== DUE) {
            kanbanTasks.move(task, DUE);
          }
        } else if (task.isComplete() && kanbanTasks.getList(task) !== DONE) {
          kanbanTasks.move(task, DONE);
        } else {
          kanbanTasks.replace(task);
        }
      }
    }
  }
  async archiveOldTasks(board) {
    const currentTasks = board.getTaskCollection();
    const archivedTasks = board.getArchive();
    for (const doneTask of currentTasks.getTasksFromLists([DONE])) {
      if (doneTask.isArchivable()) {
        archivedTasks.add(doneTask, ARCHIVE);
        currentTasks.remove(doneTask);
      }
    }
  }
};

// src/kanban/watcher.ts
var DEFAULT_TIMEOUT = 5e3;
var Watcher = class {
  constructor(kanban, timeoutValue) {
    this.timeouts = /* @__PURE__ */ new Map();
    this.kanban = kanban;
    this.timeoutValue = timeoutValue || DEFAULT_TIMEOUT;
  }
  notifyCreate(file) {
    this.timeouts.set(file.name, window.setTimeout(this.run.bind(this, file), this.timeoutValue));
  }
  notifyModify(file) {
    if (this.timeouts.has(file.name)) {
      window.clearTimeout(this.timeouts.get(file.name));
    }
    this.timeouts.set(file.name, window.setTimeout(this.run.bind(this, file), this.timeoutValue));
  }
  notifyRename(file, oldFileName) {
    if (this.timeouts.has(oldFileName)) {
      window.clearTimeout(this.timeouts.get(oldFileName));
    }
    this.timeouts.set(file.name, window.setTimeout(this.run.bind(this, file), this.timeoutValue));
  }
  notifyDelete(file) {
    if (this.timeouts.has(file.name)) {
      window.clearTimeout(this.timeouts.get(file.name));
    }
  }
  run(file) {
    this.kanban.synchroniseTasks([file]);
  }
};

// src/kanban/provider.ts
var KanbanProvider = class {
  constructor(plugin, vault, metadataCache, taskFactory, boardManager, synchroniser, watcher) {
    this.plugin = plugin;
    this.boardManager = boardManager || new KanbanBoardManager(vault, metadataCache, taskFactory);
    this.synchroniser = synchroniser || new KanbanSynchroniser(plugin, vault, taskFactory);
    this.watcher = watcher || new Watcher(this);
  }
  async synchroniseTasks(files) {
    const settings = this.plugin.getSettings();
    if (!settings.kanbanSync) {
      return;
    }
    try {
      const board = await this.boardManager.get(settings.kanbanFile);
      return this.synchroniser.process(board, files);
    } catch (err) {
      return;
    }
  }
  async getBoard() {
    const settings = this.plugin.getSettings();
    if (!settings.kanbanSync) {
      return void 0;
    }
    return await this.boardManager.get(settings.kanbanFile);
  }
  getBoardManager() {
    return this.boardManager;
  }
  getWatcher() {
    return this.watcher;
  }
};

// src/plugins/kanban.ts
var PLUGIN_NAME = "obsidian-kanban";
var KanbanPluginAdapter = class {
  constructor(app) {
    this.app = app;
  }
  isEnabled() {
    return this.app.plugins.enabledPlugins.has(PLUGIN_NAME);
  }
};

// src/plugins/tasks.ts
var PLUGIN_NAME2 = "obsidian-tasks-plugin";
var TasksPluginAdapter = class {
  constructor(app) {
    this.app = app;
  }
  async isDataViewFormat() {
    const settings = await this.loadSettings();
    return settings.taskFormat === "dataview";
  }
  isEnabled() {
    return this.app.plugins.enabledPlugins.has(PLUGIN_NAME2);
  }
  getPlugin() {
    return this.app.plugins.getPlugin(PLUGIN_NAME2);
  }
  async loadSettings() {
    return this.getPlugin().loadData();
  }
};

// src/settings/index.ts
var DEFAULT_SETTINGS = Object.freeze({
  carryOverPrefix: "",
  kanbanSync: false,
  kanbanFile: "",
  kanbanIgnoreFolders: [],
  kanbanIgnoreMatches: [],
  tasksAvailable: false,
  daily: {
    addDue: false,
    available: false,
    carryOver: false,
    header: "## TODOs",
    searchHeaders: []
  },
  weekly: {
    addDue: false,
    available: false,
    carryOver: false,
    header: "## TODOs",
    searchHeaders: []
  }
});

// src/settings/tab.ts
var import_obsidian4 = require("obsidian");

// src/ui/suggest.ts
var import_obsidian2 = require("obsidian");
var Suggest = class extends import_obsidian2.AbstractInputSuggest {
  constructor(app, options, el) {
    super(app, el);
    this.options = /* @__PURE__ */ new Set();
    this.el = el;
    options.forEach((option) => {
      this.options.add(option.path);
    });
  }
  getSuggestions(query) {
    query = query.toLocaleLowerCase();
    return [...this.options].filter((path) => path.toLocaleLowerCase().contains(query));
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
  selectSuggestion(value, evt) {
    this.el.value = value;
    this.el.dispatchEvent(new Event("input"));
    this.close();
  }
};

// src/utils/index.ts
function capitalise(text) {
  return text.charAt(0).toUpperCase() + text.slice(1);
}

// src/settings/ignore-component.ts
var import_obsidian3 = require("obsidian");
var IgnoreComponent = class {
  constructor(app, plugin, el) {
    this.app = app;
    this.plugin = plugin;
    this.el = el;
    this.settings = this.plugin.getSettings();
  }
  display() {
    this.el.empty();
    this.existingContainerEl = this.el.createDiv({ cls: "at--setting-existing-container" });
    this.buttonContainerEl = this.el.createDiv({ cls: "at--setting-button-container" });
    this.createIgnoredEntries();
    this.createAddControls();
  }
  createIgnoredEntries() {
    for (const entry of this.getIgnoredSetting()) {
      const existingWrapperEl = this.existingContainerEl.createDiv({ cls: "at--setting-existing-wrapper" });
      const existingItemEl = existingWrapperEl.createDiv({ cls: "at--setting-existing-item" });
      const existingItemControlsEl = existingItemEl.createDiv({ cls: "at--setting-existing-controls" });
      const existingItemInputEl = existingItemControlsEl.createEl("input", { type: "text" });
      existingItemInputEl.setAttribute("readonly", "readonly");
      existingItemInputEl.setAttribute("value", entry);
      const existingItemButtonsEl = existingItemEl.createDiv({ cls: "at--setting-existing-buttons" });
      const deleteEl = existingItemButtonsEl.createEl("a");
      (0, import_obsidian3.setIcon)(deleteEl, "lucide-trash-2");
      deleteEl.setAttribute("data-setting", entry);
      deleteEl.addEventListener("click", (event) => {
        this.handleRemoveIgnoredEntry(entry);
        event.stopPropagation();
      });
    }
  }
  createAddControls() {
    const controlsWrapperEl = this.buttonContainerEl.createDiv("at--setting-controls-wrapper");
    this.addEntryInputEl = controlsWrapperEl.createEl("input", { type: "text" });
    const addEl = controlsWrapperEl.createEl("button", { cls: "button", text: "Add entry" });
    addEl.addEventListener("click", (event) => {
      this.handleAddIgnoredEntry(this.addEntryInputEl.value);
      this.addEntryInputEl.value = "";
      event.stopPropagation();
    });
  }
  async handleAddIgnoredEntry(entry) {
    this.getIgnoredSetting().push(entry);
    await this.saveAndReset();
  }
  async handleRemoveIgnoredEntry(entry) {
    this.getIgnoredSetting().remove(entry);
    await this.saveAndReset();
  }
  async saveAndReset() {
    await this.plugin.updateSettings(this.settings);
    this.display();
  }
};

// src/settings/ignore-folders.ts
var IgnoreFolders = class extends IgnoreComponent {
  constructor(app, plugin, el, folders) {
    super(app, plugin, el);
    this.folders = folders.sort((a, b) => a.name.localeCompare(b.name));
  }
  getIgnoredSetting() {
    return this.settings.kanbanIgnoreFolders;
  }
  createAddControls() {
    const controlsWrapperEl = this.buttonContainerEl.createDiv("at--setting-controls-wrapper");
    this.addEntryInputEl = controlsWrapperEl.createEl("input", { type: "text" });
    new Suggest(this.app, this.folders.filter((folder) => this.settings.kanbanIgnoreFolders.indexOf(folder.path) === -1), this.addEntryInputEl);
    const addEl = controlsWrapperEl.createEl("button", { cls: "button", text: "Add folder" });
    addEl.addEventListener("click", (event) => {
      this.handleAddIgnoredEntry(this.addEntryInputEl.value);
      this.addEntryInputEl.value = "";
      event.stopPropagation();
    });
  }
};

// src/settings/ignore-matches.ts
var IgnoreMatches = class extends IgnoreComponent {
  getIgnoredSetting() {
    return this.settings.kanbanIgnoreMatches;
  }
};

// src/settings/tab.ts
var AutoTasksSettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin, kanbanPlugin, kanban) {
    super(app, plugin);
    this.vault = app.vault;
    this.plugin = plugin;
    this.kanbanPlugin = kanbanPlugin;
    this.kanban = kanban;
  }
  display() {
    this.containerEl.empty();
    let settings = this.plugin.getSettings();
    const periodicities = [
      "daily",
      "weekly"
    ];
    if (!settings.daily.available && !settings.weekly.available) {
      const periodicBannerEl = this.containerEl.createDiv({ cls: "settings-banner" });
      new import_obsidian4.Setting(periodicBannerEl).setName("No periodic notes enabled").setHeading().setDesc("No periodic notes settings are enabled. You must turn on either the daily or weekly notes within the Periodic Notes plugin settings to be able to configure automatic tasks.");
    }
    if (!settings.tasksAvailable) {
      const tasksBannerEl = this.containerEl.createDiv({ cls: "settings-banner" });
      new import_obsidian4.Setting(tasksBannerEl).setName("Tasks due date support").setHeading().setDesc("Download and enable the Tasks plugin to enable due date functionality within your tasks and TODOs.");
    }
    new import_obsidian4.Setting(this.containerEl).setName("All tasks").setHeading();
    new import_obsidian4.Setting(this.containerEl).setName("Prefix for carried over tasks").setDesc('The prefix to add to any carried over tasks, e.g. "[>]".').addText((text) => {
      text.setValue(settings.carryOverPrefix).onChange(async (val) => {
        settings.carryOverPrefix = val;
        await this.plugin.updateSettings(settings);
      });
    });
    for (const periodicity of periodicities) {
      if (settings[periodicity].available) {
        new import_obsidian4.Setting(this.containerEl).setName(`${capitalise(periodicity)} notes`).setHeading();
        new import_obsidian4.Setting(this.containerEl).setName(`Carry over ${periodicity} tasks`).setDesc(`Whether any ${periodicity} tasks that are incomplete should be automatically carried over to the following note.`).addToggle((toggle) => {
          toggle.setValue(settings[periodicity].carryOver).onChange(async (val) => {
            settings[periodicity].carryOver = val;
            await this.plugin.updateSettings(settings);
          });
        });
        if (settings.tasksAvailable) {
          new import_obsidian4.Setting(this.containerEl).setName("Add due tasks").setDesc(`Whether any tasks from anywhere else in the vault should be added that are marked as due within the ${periodicity} period.`).addToggle((toggle) => {
            toggle.setValue(settings[periodicity].addDue).onChange(async (val) => {
              settings[periodicity].addDue = val;
              await this.plugin.updateSettings(settings);
            });
          });
        }
        new import_obsidian4.Setting(this.containerEl).setName(`${capitalise(periodicity)} tasks header`).setDesc("Set the header to be added to the top of the tasks section within new notes - include any markdown to set the heading style.").addText((text) => {
          text.setValue(settings[periodicity].header).onChange(async (val) => {
            settings[periodicity].header = val;
            await this.plugin.updateSettings(settings);
          });
        });
        new import_obsidian4.Setting(this.containerEl).setName("Heading(s) to search for tasks").setDesc("Comma-separated list of headings within the notes to search and include any carry over tasks from. Leave this blank to search the entire note.").addText((text) => {
          text.setValue(settings[periodicity].searchHeaders ? settings[periodicity].searchHeaders.join(",") : "").onChange(async (val) => {
            settings[periodicity].searchHeaders = val.split(",");
            await this.plugin.updateSettings(settings);
          });
        });
      }
    }
    const kanbanEl = this.containerEl.createDiv();
    new import_obsidian4.Setting(kanbanEl).setName("Kanban board").setHeading();
    if (!this.kanbanPlugin.isEnabled()) {
      const bannerEl = kanbanEl.createDiv({ cls: "settings-banner" });
      new import_obsidian4.Setting(bannerEl).setName("Kanban support").setHeading().setDesc("Download and enable the Kanban plugin to automatically sync tasks into your chosen Kanban board.");
    } else {
      const syncSetting = new import_obsidian4.Setting(kanbanEl);
      const fileSetting = new import_obsidian4.Setting(kanbanEl);
      const ignoreFoldersSetting = new import_obsidian4.Setting(kanbanEl);
      const ignoreMatchesSetting = new import_obsidian4.Setting(kanbanEl);
      syncSetting.setName("Automatically synchronise tasks to Kanban board").setDesc("Any newly discovered tasks will be added into the Kanban board you choose.").addToggle((toggle) => {
        toggle.setValue(settings.kanbanSync).onChange(async (val) => {
          fileSetting.setDisabled(!val);
          settings.kanbanSync = val;
          await this.plugin.updateSettings(settings);
        });
      });
      const boards = this.kanban.getBoardManager().getAllBoards();
      fileSetting.setName("Primary Kanban board").setDesc("This is the Kanban board that will have tasks automatically added.").addSearch((search) => {
        search.setPlaceholder("Example: board.md").setValue(settings.kanbanFile).onChange(async (val) => {
          search.inputEl.classList.remove("has-error");
          if (boards.map((board) => board.path).indexOf(val) === -1) {
            search.inputEl.classList.add("has-error");
          } else {
            settings.kanbanFile = val;
            await this.plugin.updateSettings(settings);
          }
        });
        if (settings.kanbanSync && settings.kanbanFile === "") {
          search.inputEl.classList.add("has-error");
        }
        new Suggest(this.app, boards, search.inputEl);
      });
      ignoreFoldersSetting.setName("Folder(s) to ignore").setDesc("Select folders to ignore reading tasks from when syncing to the Kanban board.");
      new IgnoreFolders(this.app, this.plugin, ignoreFoldersSetting.settingEl.createDiv({ cls: "at--setting" }), this.vault.getAllFolders()).display();
      ignoreFoldersSetting.controlEl.remove();
      ignoreFoldersSetting.settingEl.classList.add("at--setting-item");
      ignoreMatchesSetting.setName("Task name(s) to ignore").setDesc('Enter task names to ignore when syncing to the Kanban board. You can enter regular expression patterns, e.g. "^Meeting:"');
      new IgnoreMatches(this.app, this.plugin, ignoreMatchesSetting.settingEl.createDiv({ cls: "at--setting" })).display();
      ignoreMatchesSetting.controlEl.remove();
      ignoreMatchesSetting.settingEl.classList.add("at--setting-item");
    }
  }
};

// src/tasks/provider.ts
var import_obsidian5 = require("obsidian");
var import_obsidian_periodic_notes_provider = __toESM(require_main());
var TasksProvider = class {
  constructor(vault, kanban, taskFactory, dailyNote, weeklyNote) {
    this.vault = vault;
    this.kanban = kanban;
    this.factory = taskFactory;
    this.dailyNote = dailyNote || new import_obsidian_periodic_notes_provider.DailyNote();
    this.weeklyNote = weeklyNote || new import_obsidian_periodic_notes_provider.WeeklyNote();
  }
  async checkAndCopyTasks(settings, file) {
    await this.checkAndCreateForSingleNote(settings, settings.weekly, file, this.weeklyNote);
    await this.checkAndCreateForSingleNote(settings, settings.daily, file, this.dailyNote);
  }
  async checkAndCreateForSingleNote(settings, periodicitySetting, file, cls) {
    if (periodicitySetting.available && periodicitySetting.carryOver && cls.isValid(file)) {
      const previousEntryContents = await this.vault.read(cls.getPrevious());
      const tasks = this.factory.newCollection(previousEntryContents).getTasksFromLists(periodicitySetting.searchHeaders);
      let tasksToAdd = tasks.filter((task) => !task.isComplete());
      if (settings.tasksAvailable && settings.kanbanSync && periodicitySetting.addDue) {
        const board = await this.kanban.getBoard();
        if (board !== void 0) {
          const boardTasks = board.getTaskCollection();
          for (const task of boardTasks.getTasksFromLists([UPCOMING, DUE, PROGRESS])) {
            const dueDate = task.getDueDate();
            if (dueDate && (0, import_obsidian5.moment)(dueDate).isBefore(cls.getNextDate()) && tasksToAdd.find((t) => t.equals(task)) === void 0) {
              tasksToAdd.push(task);
            }
          }
        }
      }
      if (settings.carryOverPrefix) {
        tasksToAdd = tasksToAdd.map((task) => task.markCarriedOver());
      }
      await this.vault.process(cls.getCurrent(), (contents) => {
        if (contents.indexOf(periodicitySetting.header + "\n") > -1) {
          return contents.replace(periodicitySetting.header + "\n", `${periodicitySetting.header}

${tasksToAdd.join("\n")}
`);
        }
        return `${contents}

${periodicitySetting.header}

${tasksToAdd.join("\n")}`;
      });
    }
  }
};

// src/tasks/collection.ts
var HEADER_LINE = /^#{1,6}/;
var TASK_LINE = /^-\s\[[x\s]\]/;
var TaskCollection = class {
  constructor(contents, addBoardHeaders) {
    const lines = contents.split("\n");
    this.tasks = /* @__PURE__ */ new Map();
    let currentHeader = "";
    for (const line of lines) {
      if (line.match(HEADER_LINE)) {
        currentHeader = line;
        this.tasks.set(currentHeader, []);
      }
      if (line.match(TASK_LINE)) {
        const existingTasks = this.tasks.get(currentHeader) || [];
        existingTasks.push(this.parseTask(line));
        this.tasks.set(currentHeader, existingTasks);
      }
    }
    if (addBoardHeaders) {
      if (!this.tasks.has(UPCOMING)) {
        this.tasks.set(UPCOMING, []);
      }
      if (!this.tasks.has(DUE)) {
        this.tasks.set(DUE, []);
      }
      if (!this.tasks.has(PROGRESS)) {
        this.tasks.set(PROGRESS, []);
      }
      if (!this.tasks.has(DONE)) {
        this.tasks.set(DONE, []);
      }
    }
  }
  add(task, header) {
    if (!header) {
      header = task.isComplete() ? DONE : task.isDue() ? DUE : UPCOMING;
    }
    const headerObj = this.tasks.get(header);
    if (headerObj !== void 0 && headerObj.findIndex((t) => t.equals(task)) > -1) {
      return;
    }
    headerObj == null ? void 0 : headerObj.push(task);
  }
  getAllTasks() {
    return Array.from(this.tasks.values()).flat();
  }
  getList(task) {
    for (let [list, tasks] of this.tasks) {
      for (const existingTask of tasks) {
        if (task.equals(existingTask)) {
          return list;
        }
      }
    }
    return "";
  }
  getTask(task) {
    for (const tasksList of this.tasks.values()) {
      for (const existingTask of tasksList) {
        if (existingTask.equals(task)) {
          return existingTask;
        }
      }
    }
  }
  getTasksFromLists(lists) {
    const returnTasks = [];
    this.tasks.forEach((value, list) => {
      if (!lists.length || lists[0] === "" || lists.indexOf(list) > -1) {
        returnTasks.push(...value);
      }
    });
    return returnTasks;
  }
  move(task, newList) {
    var _a, _b, _c;
    const oldList = this.getList(task);
    const index = (_a = this.tasks.get(oldList)) == null ? void 0 : _a.findIndex((t) => t.equals(task));
    if (index !== void 0 && index > -1) {
      (_b = this.tasks.get(oldList)) == null ? void 0 : _b.splice(index, 1);
    }
    (_c = this.tasks.get(newList)) == null ? void 0 : _c.push(task);
  }
  remove(task) {
    for (const tasksList of this.tasks.values()) {
      for (const existingTask of tasksList.values()) {
        if (task.equals(existingTask)) {
          tasksList.remove(existingTask);
        }
      }
    }
  }
  replace(task) {
    var _a;
    const list = this.getList(task);
    const existingTask = (_a = this.tasks.get(list)) == null ? void 0 : _a.find((t) => t.equals(task));
    if (existingTask) {
      Object.assign(existingTask, task);
    }
  }
  toString(headerSeparator) {
    headerSeparator = headerSeparator || "\n";
    let content = "";
    for (let [list, tasks] of this.tasks) {
      content = `${content}${list}

`;
      for (const task of tasks) {
        content = `${content}${task.toString()}
`;
      }
      content = `${content}${headerSeparator}`;
    }
    return content;
  }
};

// src/tasks/data-view-task.ts
var import_obsidian7 = require("obsidian");

// src/tasks/task.ts
var import_obsidian6 = require("obsidian");
var Task = class {
  constructor(line) {
    this.carriedOver = false;
    this.metadata = "";
    this.name = "";
    this.line = line;
    this.parse();
  }
  equals(task) {
    return this.name === task.getName();
  }
  getName() {
    return this.name;
  }
  isArchivable() {
    if (this.isComplete() && this.getCompletedDate()) {
      return (0, import_obsidian6.moment)(this.getCompletedDate()).isBefore((0, import_obsidian6.moment)().subtract(2, "weeks"));
    }
    return false;
  }
  isComplete() {
    return !!this.complete;
  }
  markCarriedOver() {
    this.carriedOver = true;
    return this;
  }
};

// src/tasks/data-view-task.ts
var METADATA_SETS = [
  "due",
  "created",
  "scheduled",
  "start",
  "completion",
  "cancelled",
  "priority",
  "repeat",
  "onCompletion",
  "id",
  "dependsOn"
];
var TASK_COMPLETE = /^-\s\[x\]/;
var TASK_DUE_DATE = /\s\[due::\s(\d{4}-\d{2}-\d{2})\]/;
var TASK_NAME = /^(-\s\[[x\s]\]\s)(.*?)(?:\s\[[A-Za-z]+::|$)/;
var DUE_DATE_FORMAT = "YYYY-MM-DD";
var DataViewTask = class extends Task {
  getCompletedDate() {
    const meta = this.getMetadata();
    return meta.get("completion");
  }
  getDueDate() {
    const meta = this.getMetadata();
    return meta.get("due");
  }
  getMetadata() {
    const map = /* @__PURE__ */ new Map();
    for (const metadata of METADATA_SETS) {
      if (this.metadata.includes(`[${metadata}::`)) {
        const matched = this.metadata.match(new RegExp(String.raw`\s\[${metadata}::\s(.*?)\]`));
        if (matched) {
          map.set(metadata, matched[1]);
        }
      }
    }
    return map;
  }
  isDue() {
    if (this.dueDate === void 0) {
      const matched = this.line.match(TASK_DUE_DATE);
      if (matched) {
        this.dueDate = (0, import_obsidian7.moment)(matched[1]);
      }
    }
    return !!(this.dueDate && this.dueDate.isBefore((0, import_obsidian7.moment)().add(1, "day")));
  }
  parse() {
    const matched = this.line.match(TASK_NAME);
    if (matched) {
      this.name = matched[2];
      this.metadata = this.line.replace(matched[1] + matched[2], "");
    }
    this.complete = !!this.line.match(TASK_COMPLETE);
    const carriedOverPrefix = AutoTasks.getSettings().carryOverPrefix;
    if (carriedOverPrefix && this.name.startsWith(carriedOverPrefix)) {
      this.carriedOver = true;
      this.name = this.name.replace(carriedOverPrefix + " ", "");
    }
  }
  toString() {
    const carriedOver = this.carriedOver ? AutoTasks.getSettings().carryOverPrefix + " " : "";
    const complete = this.complete ? "x" : " ";
    let metadata = this.metadata;
    if (this.dueDate) {
      metadata = metadata.replace(TASK_DUE_DATE, ` [due:: ${this.dueDate.format(DUE_DATE_FORMAT)}]`);
    }
    return `- [${complete}] ${carriedOver}${this.name}${metadata}`;
  }
};

// src/tasks/data-view-collection.ts
var DataViewTaskCollection = class extends TaskCollection {
  parseTask(line) {
    return new DataViewTask(line);
  }
};

// src/tasks/emoji-task.ts
var import_obsidian8 = require("obsidian");
var METADATA_CHARS = "\u{1F4C5}\u{1F6EB}\u23F3\u23EB\u{1F53C}\u{1F53D}\u{1F53A}\u23EC\u{1F194}\u26D4\u{1F501}\u2795\u2705";
var TASK_COMPLETE2 = /^-\s\[x\]/;
var TASK_DUE_DATE2 = /\s\s(\d{4}-\d{2}-\d{2})/;
var TASK_NAME2 = /^(-\s\[[x\s]\]\s)(.*?)(?:\s[]|$)/;
var DUE_DATE_FORMAT2 = "YYYY-MM-DD";
var EmojiTask = class extends Task {
  getCompletedDate() {
    const meta = this.getMetadata();
    return meta.get("\u2705");
  }
  getDueDate() {
    const meta = this.getMetadata();
    return meta.get("\u{1F4C5}");
  }
  getMetadata() {
    const map = /* @__PURE__ */ new Map();
    for (const char of METADATA_CHARS) {
      if (this.metadata.includes(char)) {
        const matched = this.metadata.match(new RegExp(String.raw`\s${char}\s(.*?)(?:\s|$)`));
        if (matched) {
          map.set(char, matched[1]);
        }
      }
    }
    return map;
  }
  isDue() {
    if (this.dueDate === void 0) {
      const matched = this.line.match(TASK_DUE_DATE2);
      if (matched) {
        this.dueDate = (0, import_obsidian8.moment)(matched[1]);
      }
    }
    return !!(this.dueDate && this.dueDate.isBefore((0, import_obsidian8.moment)().add(1, "day")));
  }
  parse() {
    const matched = this.line.match(TASK_NAME2);
    if (matched) {
      this.name = matched[2];
      this.metadata = this.line.replace(matched[1] + matched[2], "");
    }
    this.complete = !!this.line.match(TASK_COMPLETE2);
    const carriedOverPrefix = AutoTasks.getSettings().carryOverPrefix;
    if (carriedOverPrefix && this.name.startsWith(carriedOverPrefix)) {
      this.carriedOver = true;
      this.name = this.name.replace(carriedOverPrefix + " ", "");
    }
  }
  toString() {
    const carriedOver = this.carriedOver ? AutoTasks.getSettings().carryOverPrefix + " " : "";
    const complete = this.complete ? "x" : " ";
    let metadata = this.metadata;
    if (this.dueDate) {
      metadata = metadata.replace(TASK_DUE_DATE2, ` \u{1F4C5} ${this.dueDate.format(DUE_DATE_FORMAT2)}`);
    }
    return `- [${complete}] ${carriedOver}${this.name}${metadata}`;
  }
};

// src/tasks/emoji-collection.ts
var EmojiTaskCollection = class extends TaskCollection {
  parseTask(line) {
    return new EmojiTask(line);
  }
};

// src/tasks/factory.ts
var TaskFactory = class {
  constructor(pluginAdapter) {
    this.dataView = false;
    const t = this;
    pluginAdapter.isDataViewFormat().then((dataView) => {
      t.dataView = dataView;
    });
  }
  newCollection(contents, addBoardHeaders) {
    return this.dataView ? new DataViewTaskCollection(contents, addBoardHeaders) : new EmojiTaskCollection(contents, addBoardHeaders);
  }
  newTask(line) {
    return this.dataView ? new DataViewTask(line) : new EmojiTask(line);
  }
};

// src/index.ts
var AutoTasks = class _AutoTasks extends import_obsidian9.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.settings = DEFAULT_SETTINGS;
    const vault = app.vault;
    this.periodicNotesPlugin = new import_obsidian_periodic_notes_provider2.PeriodicNotesPluginAdapter(app);
    this.tasksPlugin = new TasksPluginAdapter(app);
    this.kanbanPlugin = new KanbanPluginAdapter(app);
    this.taskFactory = new TaskFactory(this.tasksPlugin);
    this.kanban = new KanbanProvider(this, vault, app.metadataCache, this.taskFactory);
    this.tasks = new TasksProvider(vault, this.kanban, this.taskFactory);
    _AutoTasks.instance = this;
  }
  static getSettings() {
    return _AutoTasks.instance.getSettings();
  }
  async onload() {
    this.updateSettings = this.updateSettings.bind(this);
    await this.loadSettings();
    this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
  }
  onLayoutReady() {
    if (!this.periodicNotesPlugin.isEnabled()) {
      new import_obsidian9.Notice(
        "The Periodic Notes plugin must be installed and available for Auto Tasks to work.",
        1e4
      );
      return;
    }
    this.settings.tasksAvailable = this.tasksPlugin.isEnabled();
    const workspace = this.app.workspace;
    this.registerEvent(workspace.on(import_obsidian_periodic_notes_provider2.PERIODIC_NOTES_EVENT_SETTING_UPDATED, this.syncPeriodicNotesSettings.bind(this)));
    this.syncPeriodicNotesSettings();
    this.registerEvent(this.app.vault.on("create", (file) => {
      this.tasks.checkAndCopyTasks(this.settings, file);
    }));
    this.kanban.synchroniseTasks();
    this.registerEvent(this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian9.TFile && file.name !== this.settings.kanbanFile) {
        this.kanban.getWatcher().notifyCreate(file);
      }
    }));
    this.registerEvent(this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian9.TFile && file.name !== this.settings.kanbanFile) {
        this.kanban.getWatcher().notifyModify(file);
      }
    }));
    this.registerEvent(this.app.vault.on("rename", (file, oldFileName) => {
      if (file instanceof import_obsidian9.TFile) {
        this.kanban.getWatcher().notifyRename(file, oldFileName);
      }
    }));
    this.registerEvent(this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian9.TFile) {
        this.kanban.getWatcher().notifyDelete(file);
      }
    }));
    this.addSettingTab(new AutoTasksSettingsTab(this.app, this, this.kanbanPlugin, this.kanban));
  }
  getSettings() {
    return this.settings;
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async updateSettings(settings) {
    this.settings = settings;
    await this.saveData(settings);
    this.onSettingsUpdate();
  }
  syncPeriodicNotesSettings() {
    const pluginSettings = this.periodicNotesPlugin.convertSettings();
    this.settings.daily.available = pluginSettings.daily.available;
    this.settings.weekly.available = pluginSettings.weekly.available;
    this.updateSettings(this.settings);
  }
  onSettingsUpdate() {
    this.app.workspace.trigger(SETTINGS_UPDATED);
  }
};

/* nosourcemap */